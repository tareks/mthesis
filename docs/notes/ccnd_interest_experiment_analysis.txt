A number of simple experiments using 2 nodes were conducted in order to identify how CCNX reacts in an opportunistic setting particularly in regards to how Interest retransmission works. The experiments consist of a receiver node that requests a certain CCNX URI (ccnx:/test/1) and a sender node that stores data corresponding to that URI and responds to Interest requests. The scenarios presented below identify CCNX Interest retransmission behavior using different conditions of link connectivity.

Experiment (1a) Summary:
-----------------------
This scenario involves no link interruptions or disconnections. The receiver requests information from the sender and this data is immediately satisfied.

Experiment parameters:
---------------------
- Number of nodes: 2
- Number of relay nodes: 0
- Number of links: 1
- Interest timeout period: 2 seconds
- Interval between Interest retries: 5 seconds
- File size: 512 bytes

Observations:
------------

Based on a number of runs, the experiments yields the expected end result of the data being received based on the first Interest request. The following information shows response times for the requested data being successfully received in milliseconds:
      Minimum=522, Maximum=609, Average=538.1

Analysis:
--------

The receiving node requests the CCN URI (ccnx:/test/1) at the application level which runs on top of the CCN daemon instance running on the same node. The application first sends an "interest_from" packet specifying the URI using the network face (9) it is connected to the daemon on. The Interest packet has a number of parameters, most notably its lifetime, which was set to 4 seconds for this experiment. It is possible for the application to set the value for the lifetime [1]*. When the CCN daemon receives the "interest_from" packet, it relays it over the network as an "interest_to" packet using its network face (7). Once the Interest is sent, the CCN daemon will monitor it for its specified lifetime. 
On the other node, the sender, the CCN daemon receives the "interest_from" packet on its network face (8) for a URI it serves. The Forwarding Information Baseon the node is searched for a match for that URI prefix. If one is found in the table, it will send an "interest_to" packet to the application face (7). A key request is then sent to validate the remote node. A "consume" packet is then sent to the application which then responds with a "content_from" the same application face (7). At this point, the file is cached as a Content Object in the Content Store of the sender node. A "consume" packet is sent over the network, followed by a "content_to" on the same face (8). A matching packet is received on the other end, as a "content_from" on the network face (7) followed by a "consume" to the application face (9) and finally a "content_to" the same face (9) where the actual data is read by the application from the it's CCN daemon Content Store concluding the transfer. 


Experiment (1b) Summary:
-----------------------
This scenario involves no link interruptions or disconnections. The receiver requests information from the sender and this data is immediately satisfied.

Experiment parameters:
---------------------
- Number of nodes: 2
- Number of relay nodes: 0
- Number of links: 1
- Interest timeout period: 2 seconds
- Interval between Interest retries: 5 seconds
- File size: 512 bytes

Observations:
------------

Based on a number of runs, the experiments yields the expected end result of the data being received based on the first Interest request. The following information shows response times for the requested data being successfully received in milliseconds:
      Minimum=522, Maximum=609, Average=538.1

Analysis:
--------

The receiving node requests the CCN URI (ccnx:/test/1) at the application level which runs on top of the CCN daemon instance running on the same node. The application first sends an "interest_from" packet specifying the URI using the face (9) it is connected to the daemon on. The Interest packet has a number of parameters most notably its lifetime, which was set to 4 seconds for this experiment. It is possible for the application to set the value for the lifetime [1]*. When the CCN daemon receives the "interest_from" packet, it relays it over the network as an "interest_to" packet using its network face (7). Once the Interest is sent, the CCN daemon will monitor it for its specified lifetime. 
On the other node, the sender, the CCN daemon receives the "interest_from" packet on its network face (8) for a URI it serves. The Forwarding Information Baseon the node is searched for a match for that URI prefix. If one is found in the table, it will send an "interest_to" packet to the application face (7). A key request is then sent to validate the remote node. A "consume" packet is then sent to the application which then responds with a "content_from" the same application face (7). At this point, the file is cached as a Content Object in the Content Store of the sender node. A "consume" packet is sent over the network, followed by a "content_to" on the same face (8). A matching packet is received on the other end, as a "content_from" on the network face (7) followed by a "consume" to the application face (9) and finally a "content_to" the same face (9) where the actual data is read by the application from the it's CCN daemon Content Store concluding the transfer. 





 



Analysis:
--------

On the receiving node, ccnd performs the following steps:
- Application sends a interest_from packet for the required ccnx URI (debug.3563)
-- lifetime of 4 seconds for that interest
- prefix_mismatch ? (debug.3619)
- ccnd sends an interest_to pack for the URI over the network (debug.3011)
- repeated attempts to send the request for a maximum of 13 times, timer based 4 seconds?(debug.3050) 
-- propagate_interesting() -> do_propagate() called then do_propagate is rescheduled on a timer until Interest lifetime expires
-- pe->usec is lifetime (starts at 4 seconds and decreases over time)
-- delay is 0.25 seconds, after each delay, lifetime is decreased
--- lifetime = 4 seconds; if lifetime < (16384 <  (INT_MAX / (15625 * 64)) then usec = lifetime * (15625 /64) else usec = INT_MAX 
--- pe_next_usec(): pe->usec = pe->usec - next_delay (0.25s) each iteration
- if no response, an interest_expiry packet is sent back to the application for that URI. (debug.2994) - not valid for this experiment!
- When a response is received, a "content_from" packet is received by ccnd (debug.3844)
-- a "consume" packet for that URI is sent to the application (debug.1381)
--- pe->usec (lifetime) is set to 0 (ie.expires) 
-- a "content_to" packet is sent to that application (debug.1140)


On the sender node, ccnd performs the following steps:
- ccnd receives an "interest_from" packet on the wire for a specifc ccnx URI (debug.3563)
- ccnd forwards "interest_from" packet to the application (debug.3563)
- prefix_mismatch ? (debug.3619)
- data is searched for on local cache + ccnd faces which includes sender application (debug.3302, 3050,2243)
- ccnd send "interest_to" for URI to its faces. (debug.3011)
- ccnd gets confirmation that URI exists on one of the faces? (debug.3050)
- ccnd sends "content_from" packet to retrieve that data using the URI. (debug.3844)
- ccnd sends "consume" packet to outbound face (debug.1381)
- ccnd sends "content_to" packet to outbound face (debug.1140)
- ccnd releases outbound face (debug.726)


Notes:
 - check ccnx protocol and how they match these message sequences above
 - check ccnd.c for these debug lines
 - On Sender end, the searching on local cache + faces, is that what takes so long the first time?



 - How does ccnd decide when to send interests? When application asks it to.
 - When does an interest expire? When lifetime expires, can be specified at application level?


=============
Common observations:

- information about application registration and Interests propagated during KeyStore and Content Object initialization



References:
---------
[1] http://www.ccnx.org/releases/latest/doc/technical/InterestMessage.html
* Apparently, this is not entirely true based on the implementation and http://www.ccnx.org/pipermail/ccnx-dev/2010-August/000249.html (even up till 0.6.0?)
